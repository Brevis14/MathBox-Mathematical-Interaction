<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>Three.js - 交互式正方体截面（精简版）</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        /* 左上角UI的相关样式已被移除 */
    </style>
</head>

<body>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.137.5/build/three.module.js",
            "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.137.5/examples/jsm/controls/OrbitControls.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        // 1. --- 场景初始化 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 3, 3);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        scene.add(new THREE.AmbientLight(0xaaaaaa));
        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);

        // --- 核心修改：移除中心坐标轴 ---
        // scene.add(new THREE.AxesHelper(2)); 

        // 2. --- 创建几何对象 ---
        const CUBE_SIZE = 2;
        const halfSize = CUBE_SIZE / 2;
        const cubeGeometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
        const edgesGeometry = new THREE.EdgesGeometry(cubeGeometry);
        const cube = new THREE.LineSegments(edgesGeometry, new THREE.LineBasicMaterial({ color: 0x303030, linewidth: 2 }));
        scene.add(cube);

        const controlPointPool = [];
        for (let i = 0; i < 6; i++) {
            const mesh = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            mesh.visible = false;
            scene.add(mesh);
            controlPointPool.push(mesh);
        }

        const sectionMaterial = new THREE.MeshStandardMaterial({
            color: 0x00aabb, opacity: 0.75, transparent: true, side: THREE.DoubleSide,
        });
        const sectionMesh = new THREE.Mesh(new THREE.BufferGeometry(), sectionMaterial);
        scene.add(sectionMesh);

        // 3. --- 数学计算核心 ---
        const plane = new THREE.Plane();

        const uniqueVerts = [
            new THREE.Vector3(-halfSize, -halfSize, -halfSize), new THREE.Vector3(halfSize, -halfSize, -halfSize),
            new THREE.Vector3(-halfSize, halfSize, -halfSize), new THREE.Vector3(halfSize, halfSize, -halfSize),
            new THREE.Vector3(-halfSize, -halfSize, halfSize), new THREE.Vector3(halfSize, -halfSize, halfSize),
            new THREE.Vector3(-halfSize, halfSize, halfSize), new THREE.Vector3(halfSize, halfSize, halfSize)
        ];
        const vertexToEdgesMap = [
            [0, 3, 8], [0, 1, 9], [2, 3, 11], [1, 2, 10],
            [4, 7, 8], [4, 5, 9], [6, 7, 11], [5, 6, 10]
        ];
        const cubeEdges = [
            [0, 1], [1, 3], [3, 2], [2, 0], [4, 5], [5, 7], [7, 6], [6, 4],
            [0, 4], [1, 5], [2, 6], [3, 7]
        ].map(pair => new THREE.Line3(uniqueVerts[pair[0]], uniqueVerts[pair[1]]));

        function calculateIntersection(plane) {
            const intersectionPoints = [];
            cubeEdges.forEach((edge, index) => {
                const intersection = new THREE.Vector3();
                const targetPoint = plane.intersectLine(edge, intersection);
                if (targetPoint) {
                    const closestPointOnSegment = new THREE.Vector3();
                    edge.closestPointToPoint(targetPoint, true, closestPointOnSegment);
                    if (targetPoint.distanceTo(closestPointOnSegment) < 0.0001) {
                        intersectionPoints.push({ point: targetPoint, edgeIndex: index });
                    }
                }
            });

            const uniquePoints = [];
            intersectionPoints.forEach(p => { if (!uniquePoints.some(up => up.point.distanceTo(p.point) < 0.001)) uniquePoints.push(p); });

            if (uniquePoints.length < 3) return [];

            const center = uniquePoints.reduce((acc, p) => acc.add(p.point), new THREE.Vector3()).divideScalar(uniquePoints.length);
            const u = new THREE.Vector3().subVectors(uniquePoints[0].point, center).normalize();
            const v = new THREE.Vector3().crossVectors(plane.normal, u).normalize();
            uniquePoints.sort((a, b) => {
                const vecA = new THREE.Vector3().subVectors(a.point, center);
                const vecB = new THREE.Vector3().subVectors(b.point, center);
                return Math.atan2(vecA.dot(v), vecA.dot(u)) - Math.atan2(vecB.dot(v), vecB.dot(u));
            });
            return uniquePoints;
        }

        // 4. --- 核心更新与渲染函数 ---
        const edgeToSphereMap = new Map();

        function updateScene(lockedSphere = null) {
            const intersectionData = calculateIntersection(plane);

            if (intersectionData.length < 3) {
                sectionMesh.visible = false;
            } else {
                sectionMesh.visible = true;
                const vertices3D = intersectionData.map(d => d.point);

                const center = vertices3D.reduce((acc, p) => acc.add(p), new THREE.Vector3()).divideScalar(vertices3D.length);
                const xAxis = new THREE.Vector3().subVectors(vertices3D[0], center).normalize();
                const yAxis = new THREE.Vector3().crossVectors(plane.normal, xAxis).normalize();

                const vertices2D = vertices3D.map(p => {
                    const pRelative = new THREE.Vector3().subVectors(p, center);
                    return new THREE.Vector2(pRelative.dot(xAxis), pRelative.dot(yAxis));
                });

                const shape = new THREE.Shape(vertices2D);
                const geometry = new THREE.ShapeGeometry(shape);

                const rotationMatrix = new THREE.Matrix4().makeBasis(xAxis, yAxis, plane.normal);
                geometry.applyMatrix4(rotationMatrix);
                geometry.translate(center.x, center.y, center.z);

                sectionMesh.geometry.dispose();
                sectionMesh.geometry = geometry;
            }

            const activeEdges = new Set(intersectionData.map(d => d.edgeIndex));
            intersectionData.forEach(item => {
                const { point, edgeIndex } = item;
                let sphere = edgeToSphereMap.get(edgeIndex);
                if (!sphere) {
                    const unusedSphere = controlPointPool.find(s => !s.visible);
                    if (unusedSphere) edgeToSphereMap.set(edgeIndex, unusedSphere);
                }
                sphere = edgeToSphereMap.get(edgeIndex);
                if (sphere && sphere !== lockedSphere) {
                    sphere.position.copy(point);
                }
                if (sphere) {
                    sphere.userData.edge = cubeEdges[edgeIndex];
                    sphere.visible = true;
                }
            });

            edgeToSphereMap.forEach((sphere, edgeIndex) => {
                if (!activeEdges.has(edgeIndex)) {
                    sphere.visible = false;
                    edgeToSphereMap.delete(edgeIndex);
                }
            });
        }

        // 5. --- 拖拽交互逻辑 ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const dragPlane = new THREE.Plane();
        const worldPosition = new THREE.Vector3();
        let selectedObject = null;
        let dragAnchor1 = null, dragAnchor2 = null;
        let dragStartSectionVertices = [];

        window.addEventListener('mousedown', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(controlPointPool.filter(m => m.visible));
            if (intersects.length > 0) {
                selectedObject = intersects[0].object;
                controls.enabled = false;
                dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(dragPlane.normal), intersects[0].point);

                const vertices = calculateIntersection(plane).map(d => d.point);
                dragStartSectionVertices = vertices.map(v => v.clone());
                const currentIndex = vertices.findIndex(v => v.distanceTo(selectedObject.position) < 0.01);

                if (currentIndex !== -1 && vertices.length >= 3) {
                    dragAnchor1 = vertices[(currentIndex + 1) % vertices.length];
                    dragAnchor2 = vertices[(currentIndex + vertices.length - 1) % vertices.length];
                } else {
                    selectedObject = null;
                    controls.enabled = true;
                }
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (selectedObject && dragAnchor1 && dragAnchor2) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                if (raycaster.ray.intersectPlane(dragPlane, worldPosition)) {

                    let activeEdge = selectedObject.userData.edge;

                    const vertexSnapDistance = 0.1;
                    let isAtCorner = false;
                    let cornerEdges = [];

                    for (let i = 0; i < uniqueVerts.length; i++) {
                        if (selectedObject.position.distanceTo(uniqueVerts[i]) < vertexSnapDistance) {
                            isAtCorner = true;
                            cornerEdges = vertexToEdgesMap[i].map(edgeIdx => cubeEdges[edgeIdx]);
                            break;
                        }
                    }

                    if (isAtCorner) {
                        let minDistance = Infinity;
                        let bestEdge = activeEdge;
                        cornerEdges.forEach(edge => {
                            const pointOnEdge = new THREE.Vector3();
                            edge.closestPointToPoint(worldPosition, true, pointOnEdge);
                            const dist = worldPosition.distanceTo(pointOnEdge);
                            if (dist < minDistance) {
                                minDistance = dist;
                                bestEdge = edge;
                            }
                        });
                        activeEdge = bestEdge;
                    }

                    const newPointOnEdge = new THREE.Vector3();
                    activeEdge.closestPointToPoint(worldPosition, true, newPointOnEdge);

                    selectedObject.position.copy(newPointOnEdge);

                    plane.setFromCoplanarPoints(newPointOnEdge, dragAnchor1, dragAnchor2);

                    updateScene(selectedObject);
                }
            }
        });

        window.addEventListener('mouseup', () => {
            if (selectedObject) {
                updateScene();
            }
            selectedObject = null;
            dragAnchor1 = null;
            dragAnchor2 = null;
            controls.enabled = true;
        });

        // 6. --- 动画循环与初始加载 ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        const p1 = new THREE.Vector3(0.5, 1, 1);
        const p2 = new THREE.Vector3(0.5, -1, 1);
        const p3 = new THREE.Vector3(0.5, 1, -1);
        plane.setFromCoplanarPoints(p1, p2, p3).normalize();

        updateScene();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>