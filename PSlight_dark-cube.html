<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>Three.js - 交互式正方体截面（精简版）</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .controls {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 240px;
            font-family: sans-serif;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            font-size: 14px;
            color: #333;
        }

        .control-group button {
            padding: 10px;
            font-size: 14px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .control-group button:hover {
            background-color: #f0f0f0;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type=range] {
            width: 100%;
        }
    </style>
</head>

<body>
    <div class="controls">
        <div class="control-group">
            <label for="opacity-slider">立方体透明度</label>
            <div class="slider-container">
                <span>0</span>
                <input type="range" id="opacity-slider" min="0" max="1" value="0.15" step="0.01">
                <span>1</span>
            </div>
        </div>
        <div class="control-group">
            <button id="view-section-button">观察截面</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.137.5/build/three.module.js",
            "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.137.5/examples/jsm/controls/OrbitControls.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        // 1. --- 场景初始化 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xddeeff);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2.5, 2.5, 2.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.8));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // --- 核心修改1：移除中心坐标轴 ---
        // scene.add(new THREE.AxesHelper(2));

        // 2. --- 创建几何对象 ---
        const CUBE_SIZE = 2;
        const halfSize = CUBE_SIZE / 2;
        const cubeGroup = new THREE.Group();

        const cubeMaterial = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa,
            opacity: 0.15,
            transparent: true,
            side: THREE.DoubleSide,
            metalness: 0.1,
            roughness: 0.6,
        });
        const cubeFaces = new THREE.Mesh(new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE), cubeMaterial);
        cubeGroup.add(cubeFaces);

        const edgesGeometry = new THREE.EdgesGeometry(cubeFaces.geometry);
        const cubeEdgesMesh = new THREE.LineSegments(edgesGeometry, new THREE.LineBasicMaterial({ color: 0x333333 }));
        cubeGroup.add(cubeEdgesMesh);
        scene.add(cubeGroup);

        const controlPointPool = [];
        for (let i = 0; i < 6; i++) {
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08, 32, 32), new THREE.MeshBasicMaterial({ color: 0xc73e3a }));
            mesh.visible = false;
            scene.add(mesh);
            controlPointPool.push(mesh);
        }

        const sectionMaterial = new THREE.MeshStandardMaterial({
            color: 0xff6347,
            opacity: 0.85,
            transparent: true,
            side: THREE.DoubleSide,
            metalness: 0.1,
            roughness: 0.4
        });
        const sectionMesh = new THREE.Mesh(new THREE.BufferGeometry(), sectionMaterial);
        sectionMesh.renderOrder = 1;
        scene.add(sectionMesh);

        const sectionOutline = new THREE.LineLoop(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x8b0000 }));
        sectionOutline.renderOrder = 2;
        scene.add(sectionOutline);

        // 3. --- 数学计算核心 ---
        const plane = new THREE.Plane();
        const uniqueVerts = [
            new THREE.Vector3(-halfSize, -halfSize, -halfSize), new THREE.Vector3(halfSize, -halfSize, -halfSize),
            new THREE.Vector3(-halfSize, halfSize, -halfSize), new THREE.Vector3(halfSize, halfSize, -halfSize),
            new THREE.Vector3(-halfSize, -halfSize, halfSize), new THREE.Vector3(halfSize, -halfSize, halfSize),
            new THREE.Vector3(-halfSize, halfSize, halfSize), new THREE.Vector3(halfSize, halfSize, halfSize)
        ];
        const vertexToEdgesMap = [[0, 3, 8], [0, 1, 9], [2, 3, 11], [1, 2, 10], [4, 7, 8], [4, 5, 9], [6, 7, 11], [5, 6, 10]];
        const cubeEdges = [[0, 1], [1, 3], [3, 2], [2, 0], [4, 5], [5, 7], [7, 6], [6, 4], [0, 4], [1, 5], [2, 6], [3, 7]].map(pair => new THREE.Line3(uniqueVerts[pair[0]], uniqueVerts[pair[1]]));

        function calculateIntersection(plane) {
            const intersectionPoints = [];
            cubeEdges.forEach((edge, index) => {
                const intersection = new THREE.Vector3();
                const targetPoint = plane.intersectLine(edge, intersection);
                if (targetPoint) {
                    const closestPointOnSegment = new THREE.Vector3();
                    edge.closestPointToPoint(targetPoint, true, closestPointOnSegment);
                    if (targetPoint.distanceTo(closestPointOnSegment) < 0.0001) {
                        intersectionPoints.push({ point: targetPoint, edgeIndex: index });
                    }
                }
            });
            const uniquePoints = [];
            intersectionPoints.forEach(p => { if (!uniquePoints.some(up => up.point.distanceTo(p.point) < 0.001)) uniquePoints.push(p); });
            if (uniquePoints.length < 3) return [];
            const center = uniquePoints.reduce((acc, p) => acc.add(p.point), new THREE.Vector3()).divideScalar(uniquePoints.length);
            const u = new THREE.Vector3().subVectors(uniquePoints[0].point, center).normalize();
            const v = new THREE.Vector3().crossVectors(plane.normal, u).normalize();
            uniquePoints.sort((a, b) => {
                const vecA = new THREE.Vector3().subVectors(a.point, center);
                const vecB = new THREE.Vector3().subVectors(b.point, center);
                return Math.atan2(vecA.dot(v), vecA.dot(u)) - Math.atan2(vecB.dot(v), vecB.dot(u));
            });
            return uniquePoints;
        }

        // 4. --- 核心更新与渲染函数 ---
        const edgeToSphereMap = new Map();
        function updateScene(lockedSphere = null) {
            const intersectionData = calculateIntersection(plane);
            if (intersectionData.length < 3) {
                sectionMesh.visible = false;
                sectionOutline.visible = false;
            } else {
                sectionMesh.visible = true;
                sectionOutline.visible = true;
                const vertices = intersectionData.map(d => d.point);
                const coplanarVertices = vertices.map(v => plane.projectPoint(v, new THREE.Vector3()));
                const verticesArray = new Float32Array(coplanarVertices.length * 3);
                coplanarVertices.forEach((p, i) => p.toArray(verticesArray, i * 3));
                const indices = [];
                for (let i = 1; i < coplanarVertices.length - 1; i++) {
                    indices.push(0, i, i + 1);
                }
                sectionMesh.geometry.dispose();
                const newGeometry = new THREE.BufferGeometry();
                newGeometry.setAttribute('position', new THREE.BufferAttribute(verticesArray, 3));
                newGeometry.setIndex(indices);
                newGeometry.computeVertexNormals();
                sectionMesh.geometry = newGeometry;
                sectionOutline.geometry.dispose();
                sectionOutline.geometry = new THREE.BufferGeometry().setFromPoints(coplanarVertices);
            }
            const activeEdges = new Set(intersectionData.map(d => d.edgeIndex));
            intersectionData.forEach(item => {
                const { point, edgeIndex } = item;
                let sphere = edgeToSphereMap.get(edgeIndex);
                if (!sphere) { const unusedSphere = controlPointPool.find(s => !s.visible); if (unusedSphere) edgeToSphereMap.set(edgeIndex, unusedSphere); }
                sphere = edgeToSphereMap.get(edgeIndex);
                if (sphere && sphere !== lockedSphere) { sphere.position.copy(point); }
                if (sphere) { sphere.userData.edge = cubeEdges[edgeIndex]; sphere.visible = true; }
            });
            edgeToSphereMap.forEach((sphere, edgeIndex) => {
                if (!activeEdges.has(edgeIndex)) { sphere.visible = false; edgeToSphereMap.delete(edgeIndex); }
            });
        }

        // 5. --- 拖拽交互逻辑与UI事件监听 ---
        const opacitySlider = document.getElementById('opacity-slider');
        opacitySlider.addEventListener('input', (event) => {
            cubeMaterial.opacity = parseFloat(event.target.value);
        });

        const viewSectionButton = document.getElementById('view-section-button');
        viewSectionButton.addEventListener('click', () => {
            const intersectionData = calculateIntersection(plane);
            if (intersectionData.length < 3) return;
            controls.enabled = false;
            const vertices = intersectionData.map(d => d.point);
            const target = vertices.reduce((acc, p) => acc.add(p), new THREE.Vector3()).divideScalar(vertices.length);
            let maxDistSq = 0;
            vertices.forEach(v => { maxDistSq = Math.max(maxDistSq, v.distanceToSquared(target)); });
            const distance = Math.sqrt(maxDistSq) / Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
            const cameraTargetPos = new THREE.Vector3().copy(target).add(plane.normal.clone().multiplyScalar(distance * 1.5 + 1));
            const controlTargetPos = target;
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            let alpha = 0;
            const duration = 1;
            let startTime = null;
            function animateCamera(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = (timestamp - startTime) / 1000;
                alpha = Math.min(elapsed / duration, 1);
                const easedAlpha = 1 - Math.pow(1 - alpha, 3);
                camera.position.lerpVectors(startPos, cameraTargetPos, easedAlpha);
                controls.target.lerpVectors(startTarget, controlTargetPos, easedAlpha);
                if (alpha < 1) { requestAnimationFrame(animateCamera); } else { controls.enabled = true; }
            }
            requestAnimationFrame(animateCamera);
        });

        const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(); const dragPlane = new THREE.Plane();
        const worldPosition = new THREE.Vector3(); let selectedObject = null; let dragAnchor1 = null, dragAnchor2 = null; let dragStartSectionVertices = [];
        window.addEventListener('mousedown', (event) => { if (event.target.tagName === 'INPUT' || event.target.tagName === 'BUTTON') return; mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(controlPointPool.filter(m => m.visible)); if (intersects.length > 0) { selectedObject = intersects[0].object; controls.enabled = false; dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(dragPlane.normal), intersects[0].point); const vertices = calculateIntersection(plane).map(d => d.point); dragStartSectionVertices = vertices.map(v => v.clone()); const currentIndex = vertices.findIndex(v => v.distanceTo(selectedObject.position) < 0.01); if (currentIndex !== -1 && vertices.length >= 3) { dragAnchor1 = vertices[(currentIndex + 1) % vertices.length]; dragAnchor2 = vertices[(currentIndex + vertices.length - 1) % vertices.length] } else { selectedObject = null; controls.enabled = true } } });
        window.addEventListener('mousemove', (event) => { if (selectedObject && dragAnchor1 && dragAnchor2) { mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); if (raycaster.ray.intersectPlane(dragPlane, worldPosition)) { let activeEdge = selectedObject.userData.edge; const vertexSnapDistance = 0.1; let isAtCorner = false; let cornerEdges = []; for (let i = 0; i < uniqueVerts.length; i++) { if (selectedObject.position.distanceTo(uniqueVerts[i]) < vertexSnapDistance) { isAtCorner = true; cornerEdges = vertexToEdgesMap[i].map(edgeIdx => cubeEdges[edgeIdx]); break } } if (isAtCorner) { let minDistance = Infinity; let bestEdge = activeEdge; cornerEdges.forEach(edge => { const pointOnEdge = new THREE.Vector3(); edge.closestPointToPoint(worldPosition, true, pointOnEdge); const dist = worldPosition.distanceTo(pointOnEdge); if (dist < minDistance) { minDistance = dist; bestEdge = edge } }); activeEdge = bestEdge } const newPointOnEdge = new THREE.Vector3(); activeEdge.closestPointToPoint(worldPosition, true, newPointOnEdge); selectedObject.position.copy(newPointOnEdge); plane.setFromCoplanarPoints(newPointOnEdge, dragAnchor1, dragAnchor2); updateScene(selectedObject) } } });
        window.addEventListener('mouseup', () => { if (selectedObject) { updateScene() } selectedObject = null; dragAnchor1 = null; dragAnchor2 = null; controls.enabled = true; });

        // 6. --- 动画循环与初始加载 ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        plane.setFromCoplanarPoints(new THREE.Vector3(0.5, 1, 1), new THREE.Vector3(0.5, -1, 1), new THREE.Vector3(0.5, 1, -1)).normalize();
        updateScene();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>
